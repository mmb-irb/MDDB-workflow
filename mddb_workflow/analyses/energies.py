# Energies
#
# The energies analysis is carried by ACPYPE and a locally developed tool: CMIP.
# ACPYPE is a tool based in Python to use Antechamber to generate topologies for chemical compounds and to interface with others python applications.
# CMIP stands for Classical Molecular Interaction Potential and it is usefull to predict electrostatic and Van der Waals potentials.
#
# ACPYPE:
# SOUSA DA SILVA, A. W. & VRANKEN, W. F. ACPYPE - AnteChamber PYthon Parser interfacE. BMC Research Notes 5 (2012), 367 doi: 10.1186/1756-0500-5-367 http://www.biomedcentral.com/1756-0500/5/367
# BATISTA, P. R.; WILTER, A.; DURHAM, E. H. A. B. & PASCUTTI, P. G. Molecular Dynamics Simulations Applied to the Study of Subtypes of HIV-1 Protease. Cell Biochemistry and Biophysics 44 (2006), 395-404. doi: 10.1385/CBB:44:3:395
#
# Antechamber:
# WANG, J., WANG, W., KOLLMAN, P. A., and CASE, D. A. Automatic atom type and bond type perception in molecular mechanical calculations. Journal of Molecular Graphics and Modelling 25, 2 (2006), 247–260. doi: 10.1016/j.jmgm.2005.12.005
# WANG, J., WOLF, R. M., CALDWELL, J. W., KOLLMAN, P. A., and CASE, D. A. Development and testing of a General Amber Force Field. Journal of Computational Chemistry 25, 9 (2004), 1157–1174. doi: 10.1002/jcc.20035
#
# CMIP:
# Gelpí, J.L., Kalko, S.G., Barril, X., Cirera, J., de la Cruz, X., Luque, F.J. and Orozco, M. (2001), Classical molecular interaction potentials: Improved setup procedure in molecular dynamics simulations of proteins. Proteins, 45: 428-437. doi:10.1002/prot.1159

# Imports libraries
from os import mkdir, remove
from os.path import exists
from shutil import copyfile
from glob import glob
import re
import math
from subprocess import run, PIPE

from mddb_workflow.tools.get_pdb_frames import get_pdb_frames
from mddb_workflow.utils.auxiliar import load_json, save_json, warn, numerate_filename, get_analysis_name
from mddb_workflow.utils.constants import OUTPUT_ENERGIES_FILENAME
from mddb_workflow.utils.constants import PROTEIN_RESIDUE_NAME_LETTERS, NUCLEIC_RESIDUE_NAME_LETTERS
from mddb_workflow.utils.constants import CMIP_INPUTS_CHECKONLY_SOURCE, CMIP_INPUTS_SOURCE
from mddb_workflow.utils.constants import CMIP_VDW_SOURCE, ENERGIES_DEBUG_SCRIPT_SOURCE
from mddb_workflow.utils.structures import Structure
from mddb_workflow.utils.file import File
from mddb_workflow.utils.type_hints import *

CURSOR_UP_ONE = '\x1b[1A'
ERASE_LINE = '\x1b[2K'
ERASE_3_PREVIOUS_LINES = CURSOR_UP_ONE + ERASE_LINE + CURSOR_UP_ONE + ERASE_LINE + CURSOR_UP_ONE + ERASE_LINE + CURSOR_UP_ONE

def energies (
    trajectory_file : File,
    # Set a folder to be created in order to store residual output files from this analysis
    output_directory : str,
    structure : 'Structure',
    interactions : list,
    charges : list,
    snapshots : int,
    frames_limit : int = 100,
    verbose : bool = False,
    debug : bool = False):
    """Perform the electrostatic and vdw energies analysis for each pair of interaction agents."""

    # Make sure we have interactions
    if not interactions or len(interactions) == 0:
        print('No interactions were specified')
        return

    # Make sure we have charges
    if not charges or type(charges) == Exception:
        print('Atom charges are not available -> This analysis will be skipped')
        return
    
    # Set the main output filepath
    output_analysis_filepath = f'{output_directory}/{OUTPUT_ENERGIES_FILENAME}'

    # Set the auxiliar files further required as CMIP inputs
    cmip_inputs_checkonly_source = File(CMIP_INPUTS_CHECKONLY_SOURCE)
    cmip_inputs_source = File(CMIP_INPUTS_SOURCE)
    vdw_source = File(CMIP_VDW_SOURCE)
    debug_script_source = File(ENERGIES_DEBUG_SCRIPT_SOURCE)

    # Set a backup file to store some results on the fly
    # This is useful to restore these values in case the analysis is disrupt since it is a long analysis
    energies_backup = File(output_directory + '/backup.json')

    # Define an additional file generated by CMIP which must be handled (written in the energies folder and deleted)
    restart_file = File(output_directory + '/restart')

    # Check the number of atoms on each interacting agent
    # If there is any agent with more than 80000 atoms CMIP will fail so we must skip this specific energies analysis by now
    # DANI: Este valor límite se puede cambiar en CMIP, pero hay que recompilar y eso no es banal en un environment de conda
    cmip_atom_limit = 80000
    for interaction in interactions:
        exceeds = False
        for agent in ['1', '2']:
            atoms = interaction[f'atom_indices_{agent}']
            atom_count = len(atoms)
            if atom_count >= cmip_atom_limit:
                exceeds = True
                break
        if exceeds:
            warn(f'{interaction["name"]} is exceeding the CMIP atom count limit of {cmip_atom_limit} and it will be skipped for this analysis')
            interaction['exceeds'] = True

    # This anlaysis produces many residual output files
    # Create a new folder to store all ouput files so they do not overcrowd the main directory
    if not exists(output_directory):
        mkdir(output_directory)

    # Adapt the structure for cmip
    energies_structure = structure.copy()

    # Rename residues according to if they are terminals
    name_terminal_residues(energies_structure)

    # Set each atom element in CMIP format
    set_cmip_elements(energies_structure)

    # Save the structure back to a pdb
    energies_structure_file = File(output_directory + '/energies.pdb')
    energies_structure.generate_pdb_file(energies_structure_file.path)

    # Transform an agent structure to a cmip input pdb, which includes charges and cmip-friendly elements
    # If this is to be a host file then leave only atoms involved in the interaction: both host and guest agents
    # If this is to be a host file, all guest atoms are set dummy* as well
    # If this is to be a guest file then remove all host atoms as well
    # Note that the frame structure is not the standard structure, which would already include charges
    # For this reason, charges are included in the frame structure before
    # Also flag some atoms as 'dummy' by adding a 'X' before the element
    # *Dummy atoms are not considered in the calculation but they stand for a region with low dielectric
    # If removed, the void left by these atoms would be considered to be filled with solvent, which has a high dielectric
    # These dielectric differences have a strong impact on the calculation
    # By default we set as dummy host atoms involved in a covalent bond with guest atoms
    def pdb2cmip (
        agent_name : str,
        host_file : bool,
        frame_structure : 'Structure',
        host_selection : 'Selection',
        guest_selection : 'Selection',
        strong_bonds : Optional[list]
    ) -> File:
        # Get atom indices for host atoms involved in a covalent bond with guest atoms
        # If this is the host, they will be further marked as dummy for CMIP to ignore them in the calculations
        # If this is the guest, they will be removed
        strong_bond_atom_indices = []
        if strong_bonds:
            for bond in strong_bonds:
                strong_bond_atom_indices += bond
        # Set atoms to be flagged as dummy
        dummy_atom_indices = set()
        # If this is to be the host file then set guest atoms and strong bond atoms dummy
        if host_file:
            dummy_atom_indices |= set(strong_bond_atom_indices)
            dummy_atom_indices |= set(guest_selection.atom_indices)
        # Set which atoms must be kept in the output file
        # If this is the host file then keep both host and guest atoms
        # If this is the guest file then keep only guest atoms
        # Always remove strong bond atoms in the guest
        selection = host_selection + guest_selection if host_file else guest_selection
        strong_bond_selection = frame_structure.select_atom_indices(strong_bond_atom_indices)
        guest_strong_bonds = guest_selection & strong_bond_selection
        selection -= guest_strong_bonds
        # Filter the selected atoms in the structure
        selected_structure = frame_structure.filter(selection)
        # Set atom charges (non standard attribute), which are used further to write the adapted cmip pdb
        # Set also the elements to macth the original structure, since the frame generator messes the elements
        for a, atom in enumerate(selected_structure.atoms):
            atom_index = selection.atom_indices[a]
            charge = charges[atom_index]
            setattr(atom, 'charge', charge)
            cmip_element = energies_structure.atoms[atom_index].element
            atom.element = cmip_element
        # Write a special pdb which contains charges as CMIP expects to find them and dummy atoms flagged
        output_filepath = f'{output_directory}/{agent_name}_{"host" if host_file else "guest"}.cmip.pdb'
        with open(output_filepath, "w") as file:
            # Write a line for each atom
            for a, atom in enumerate(selected_structure.atoms):
                index = str(a+1).rjust(5)
                atom_name = atom.name
                name =  ' ' + atom_name.ljust(3) if len(atom_name) < 4 else atom_name
                residue = atom.residue
                residue_name = residue.name.ljust(3)
                chain = atom.chain
                chain_name = chain.name.rjust(1)
                residue_number = str(residue.number).rjust(4)
                icode = residue.icode.rjust(1)
                coords = atom.coords
                x_coord, y_coord, z_coord = [ "{:.3f}".format(coord).rjust(8) for coord in coords ]
                charge = "{:.4f}".format(atom.charge) # Charge was manually added before, it is not a standard attribute
                # In case this atom is making an strong bond between both interacting agents we add an 'X' before the element
                # This way CMIP will ignore the atom. Otherwise it would return high non-sense Van der Waals values
                real_index = selection.atom_indices[a]
                # Set if atom is to be ignored
                is_dummy = real_index in dummy_atom_indices
                cmip_dummy_flag = 'X' if is_dummy else ''
                element = atom.element
                atom_line = ('ATOM  ' + index + ' ' + name + ' ' + residue_name + ' '
                    + chain_name + residue_number + icode + '   ' + x_coord + y_coord + z_coord
                    + ' ' + str(charge).rjust(7) + '  ' + cmip_dummy_flag + element + '\n')
                file.write(atom_line)

        return File(output_filepath)

    # Run CMIP in 'checkonly' mode (i.e. start and stop) for both agents
    # Mine the grid generated by CMIP for both agents and calculate a new grid which would include both
    # Finally, modify the provided 'cmip_inputs' with the new grid parameters
    def adapt_cmip_grid (agent1_cmip_pdb : File, agent2_cmip_pdb : File, cmip_inputs : File) -> tuple:

        # Set a name for the checkonly CMIP outputs
        # This name is not important, since the data we want is in the CMIP logs
        cmip_checkonly_output = File(output_directory + '/checkonly.energy.pdb')

        # Run CMIP in 'checkonly' mode and save the grid dimensions output
        # First do it for the agent 1
        cmip_logs_agent1 = run([
            "cmip",
            "-i",
            cmip_inputs_checkonly_source.path,
            "-pr",
            agent1_cmip_pdb.path,
            "-vdw",
            vdw_source.path,
            "-hs",
            agent2_cmip_pdb.path,
            "-byat",
            cmip_checkonly_output.path,
            "-rst",
            restart_file.path
        ], stdout=PIPE, stderr=PIPE).stdout.decode()

        # Mine the grid dimensions from CMIP logs
        agent1_center, agent1_density, agent1_units = mine_cmip_output(
            cmip_logs_agent1.split("\n"))

        # Run CMIP in 'checkonly' mode and save the grid dimensions output
        # Now do it for the agent 2
        cmip_logs_agent2 = run([
            "cmip",
            "-i",
            cmip_inputs_checkonly_source.path,
            "-pr",
            agent2_cmip_pdb.path,
            "-vdw",
            vdw_source.path,
            "-hs",
            agent1_cmip_pdb.path,
            "-byat",
            cmip_checkonly_output.path,
            "-rst",
            restart_file.path
        ], stdout=PIPE, stderr=PIPE).stdout.decode()

        # Mine the grid dimensions from CMIP logs
        agent2_center, agent2_density, agent2_units = mine_cmip_output(
            cmip_logs_agent2.split("\n"))

        # Calculate grid dimensions for a new grid which contains both previous grids
        new_center, new_density = compute_new_grid(
            agent1_center,
            agent1_density,
            agent1_units,
            agent2_center,
            agent2_density,
            agent2_units)

        # Here we must calculate how many grid points the new box would have
        # In case the number of points exceeds a safe limit we must reduce it
        # Otherwise CMIP could return the following error:
        # ERROR when trying to allocate           -2092351636  bytes of memory

        # Set the limit number of grid points
        # It has been found experimentally: 65945880 Grid points -> OK, 68903412 Grid points -> ERROR
        grid_points_limit = 65000000

        # Set the default grid 'cells' size for all three dimensions
        grid_unit_size = 0.5

        # Calculate the amount of total points with current parameters
        current_grid_points = (new_density[0] + 1) * (new_density[1] + 1) * (new_density[2] + 1)

        # In case the current number of grid points exceeds the limit...
        # Reduce all dimension densities in proportion and expand the grid units size to compensate
        if current_grid_points > grid_points_limit:
            print(f'WARNING: Grid points limit is exceeded ({current_grid_points})')
            proportion = grid_points_limit / current_grid_points
            new_density[0] = math.ceil(new_density[0] * proportion)
            new_density[1] = math.ceil(new_density[1] * proportion)
            new_density[2] = math.ceil(new_density[2] * proportion)
            grid_unit_size = math.ceil(grid_unit_size / proportion * 1000) / 1000
            print(f'WARNING: Grid resolution has been reduced -> unit size = {grid_unit_size}')

        # Set the new lines to be written in the local CMIP inputs file
        grid_inputs = [
            f" cenx={new_center[0]:.1f} \n",
            f" ceny={new_center[1]:.1f} \n",
            f" cenz={new_center[2]:.1f} \n",
            f" dimx={int(new_density[0])} \n",
            f" dimy={int(new_density[1])} \n",
            f" dimz={int(new_density[2])} \n",
            f" intx={grid_unit_size} \n",
            f" inty={grid_unit_size} \n",
            f" intz={grid_unit_size} \n",
        ]
        # Add previous lines to the local inputs file
        with open(cmip_inputs.path, "r+") as file:
            lines = file.readlines()
            file.seek(0)
            for line in lines:
                if line == '&end \n':
                    for grid_input in grid_inputs:
                        file.write(grid_input)
                file.write(line)

        # Delete the 'ckeckonly' file
        cmip_checkonly_output.remove()

        # Calculate the resulting box origin and size and return both values
        # These values are used for display / debug purposes only
        new_size = (new_density[0] * grid_unit_size, new_density[1] * grid_unit_size, new_density[2] * grid_unit_size)
        new_origin = (new_center[0] - new_size[0] / 2, new_center[1] - new_size[1] / 2, new_center[2] - new_size[2] / 2)
        return new_origin, new_size

    # Run the CMIP software to get the desired energies
    def get_cmip_energies (cmip_inputs : File, guest : File, host : File) -> tuple:
        # Set the cmip output filename, which is to be read rigth after it is generated
        cmip_output_file = File(output_directory + '/cmip_output.pdb')
        # Run cmip
        cmip_process = run([
            "cmip",
            "-i",
            cmip_inputs.path,
            "-pr",
            guest.path,
            "-vdw",
            vdw_source.path,
            "-hs",
            host.path,
            "-byat",
            cmip_output_file.path,
            "-rst",
            restart_file.path,
        ], stdout=PIPE, stderr=PIPE)
        cmip_logs = cmip_process.stdout.decode()
        # If the output does note exist at this poin then it means something went wrong with CMIP
        if not exists(cmip_output_file.path):
            print(cmip_logs)
            cmip_error_logs = cmip_process.stderr.decode()
            print(cmip_error_logs)
            raise RuntimeError('Something went wrong with CMIP!')
        # Mine the electrostatic (es) and Van der Walls (vdw) energies for each atom
        # Group the results by atom adding their values
        atom_energies = []
        with open(cmip_output_file.path, 'r') as file:
            lines = list(file)
            # If this file is empty it means something went wrong with CMIP
            # We print its logs and exit
            if len(lines) == 0:
                if type(cmip_logs) == str:
                    print(cmip_logs)
                else:
                    for line in cmip_logs:
                        print(line)
                raise SystemExit('ERROR: Something went wrong with CMIP!')
            # Mine energies line by line (i.e. atom by atom)
            for line in lines:
                # WARNING: This works most times but there is an exception
                # vdw = float(line[42:53])
                # es = float(line[57:68])
                # both = float(line[72:83])
                # Numbers may become larger than expected when they are close to 0 since they are expressed in E notation
                # e.g. 0.1075E-04
                # For this reason we must mine these last values relying on whitespaces between them
                line_splits = line.split()
                vdw = float(line_splits[-3])
                es = float(line_splits[-2])
                both = float(line_splits[-1])
                # Values greater than 100 are represented as 0
                # This step is performed to filter 'infinity' values
                energies = (vdw, es, both)
                if both > 100:
                    #print('WARNING: We have extremly high values in energies which are beeing discarded')
                    energies = (0, 0, 0)
                # Add current atom energy values to the atom energies list
                atom_energies.append(energies)
        return atom_energies

    # Given a pdb structure, use CMIP to extract energies
    # Output energies are returned by atom
    def get_frame_energy (frame_structure : 'Structure') -> list[dict]:

        # WARNING: At this point structure should be corrected
        # WARNING: Repeated atoms will make the analysis fail

        # Repeat the whole process for each interaction
        data = []
        for interaction in interactions:

            # Check if the interaction has been marked as 'exceeds', in which case we skip it
            if interaction.get('exceeds', False):
                continue

            # Get covalent bonds between both agents, if any
            # They will be not taken in count during the calculation
            # Otherwise we would have a huge energy peak in this atom since they are very close
            strong_bonds = interaction.get('strong_bonds', None)

            # Get interaction and agent names, just for the logs
            interaction_name = interaction['name']
            print(f' Processing {interaction_name}')
            agent1_name = interaction['agent_1'].replace(' ', '_').replace('/', '_')
            agent2_name = interaction['agent_2'].replace(' ', '_').replace('/', '_')
            # Get agent atom selections
            agent1_atom_indices = interaction[f'atom_indices_1']
            agent1_selection = frame_structure.select_atom_indices(agent1_atom_indices)
            if not agent1_selection:
                raise ValueError(f'Empty agent 1 "{agent1_name}" from interaction "{interaction_name}"')
            agent2_atom_indices = interaction[f'atom_indices_2']
            agent2_selection = frame_structure.select_atom_indices(agent2_atom_indices)
            if not agent2_selection:
                raise ValueError(f'Empty agent 2 "{agent2_name}" from interaction "{interaction_name}"')

            # Prepare the CMIP friendly input pdb structures for every calculation
            # First prepare the host files and the prepare the guest files
            # There is only a difference between host and guest files:
            # Host files include both agent atoms but the guest atoms are all marked as dummy
            # Guest files include only guest atoms while host atoms are removed
            agent1_cmip_host = pdb2cmip(agent_name = agent1_name, host_file = True, frame_structure=frame_structure,
                host_selection=agent1_selection, guest_selection=agent2_selection, strong_bonds=strong_bonds)
            agent2_cmip_host = pdb2cmip(agent_name = agent2_name, host_file = True, frame_structure=frame_structure,
                host_selection=agent2_selection, guest_selection=agent1_selection, strong_bonds=strong_bonds)
            agent1_cmip_guest = pdb2cmip(agent_name = agent1_name, host_file = False, frame_structure=frame_structure,
                host_selection=agent2_selection, guest_selection=agent1_selection, strong_bonds=strong_bonds)
            agent2_cmip_guest = pdb2cmip(agent_name = agent2_name, host_file = False, frame_structure=frame_structure,
                host_selection=agent1_selection, guest_selection=agent2_selection, strong_bonds=strong_bonds)

            # Copy the source cmip inputs file in the local directory
            # Inputs will be modified to adapt the cmip grid to both agents together
            # Note than modified inputs file is not conserved along frames
            # Structures may change along trajectory thus requiring a different grid size
            cmip_inputs_filename = cmip_inputs_source.filename
            cmip_inputs = File(f'{output_directory}/{cmip_inputs_filename}')
            copyfile(cmip_inputs_source.path, cmip_inputs.path)

            # Set the CMIP box dimensions and densities to fit both the host and the guest
            # Box origin and size are modified in the cmip inputs
            # Values returned are only used for display / debug purposes
            box_origin, box_size = adapt_cmip_grid(agent1_cmip_guest, agent2_cmip_guest, cmip_inputs)

            # If the debug flag is passed then, instead of calculating energies, leave it all ready and stop here
            if debug:
                # Copy in the energies folder a small python script used to sum output energies
                debug_script_filename = debug_script_source.filename
                debug_script = File(f'{output_directory}/{debug_script_filename}')
                copyfile(debug_script_source.path, debug_script.path)
                # Copy in the energies folder the VDM parameters input file
                debug_vdw_filename = vdw_source.fiename
                debug_vdw_parameters = File(f'{output_directory}/{debug_vdw_filename}')
                copyfile(vdw_source.path, debug_vdw_parameters.path)
                # Set auxiliar output filenames
                debug_output_1 = 'first_output.pdb'
                debug_output_2 = 'second_output.pdb'
                # Write a README file explaining what to do to manually debug CMIP
                debug_readme = File(f'{output_directory}/README')
                with open(debug_readme.path, 'w') as file:
                    file.write(
                        '# Energies debug\n\n'
                        '# Run CMIP\n'
                        f'cmip -i {cmip_inputs_filename} -pr {agent1_cmip_guest.filename} -vdw {debug_vdw_filename} -hs {agent2_cmip_host.filename} -byat {debug_output_1}\n\n'
                        '# Run CMIP inverting host and guest\n'
                        f'cmip -i {cmip_inputs_filename} -pr {agent2_cmip_guest.filename} -vdw {debug_vdw_filename} -hs {agent1_cmip_host.filename} -byat {debug_output_2}\n\n'
                        '# Sum both energies and compare\n'
                        f'python {debug_script_filename} {debug_output_1} {debug_output_2}\n'
                    )
                raise SystemExit(' READY TO DEBUG -> Please go to the corresponding replica "energies" directory and follow the README instructions')

            # Run the CMIP software to get the desired energies
            print(f'  Calculating energies for {agent1_name} as guest and {agent2_name} as host')
            agent1_atom_energies = get_cmip_energies(cmip_inputs, agent1_cmip_guest, agent2_cmip_host)
            print(f'  Calculating energies for {agent2_name} as guest and {agent1_name} as host')
            agent2_atom_energies = get_cmip_energies(cmip_inputs, agent2_cmip_guest, agent1_cmip_host)

            # Add None in those places where there is a strong bond
            strong_bond_atom_indices = set(sum(strong_bonds, []))
            for i, atom_index in enumerate(agent1_atom_indices):
                if atom_index in strong_bond_atom_indices:
                    agent1_atom_energies.insert(i, None)
            for i, atom_index in enumerate(agent2_atom_indices):
                if atom_index in strong_bond_atom_indices:
                    agent2_atom_energies.insert(i, None)

            # Make sure the output size matches the number of atoms in the interaction
            if len(agent1_atom_energies) != len(agent1_atom_indices):
                print(f'Number of values: {len(agent1_atom_energies)}')
                print(f'Number of atoms: {len(agent1_atom_indices)}')
                raise ValueError('Missmatch in the number values and atoms in agent 1')
            if len(agent2_atom_energies) != len(agent2_atom_indices):
                print(f'Number of values: {len(agent2_atom_energies)}')
                print(f'Number of atoms: {len(agent2_atom_indices)}')
                raise ValueError('Missmatch in the number values and atoms in agent 2')

            # Print total energies at the end for every agent if the verbose flag has been passed
            if verbose:
                for agent_name, agent_energies in zip([agent1_name, agent2_name], [agent1_atom_energies, agent2_atom_energies]):
                    total_vdw = total_es = total_both = 0
                    for atom_energies in agent_energies:
                        total_vdw += atom_energies[0]
                        total_es += atom_energies[1]
                        total_both += atom_energies[2]
                    print(f' Total energies for {agent_name}: vmd {total_vdw}, es {total_es}, both {total_both}')

            # DANI: Usa esto para escribir los resultados de las energías por átomo
            # sample = {
            #     'agent1': { 'energies': agent1_atom_energies, 'pdb': agent1_cmip },
            #     'agent2': { 'energies': agent2_atom_energies, 'pdb': agent2_cmip },
            #     'box': { 'origin': box_origin, 'size': box_size } 
            # }
            # save_json(sample, 'energies_sample.json')

            data.append({ 'agent1': agent1_atom_energies, 'agent2': agent2_atom_energies })

            # Erase the 2 previous log lines
            print(ERASE_3_PREVIOUS_LINES)

        return data

    # Extract the energies for each frame in a reduced trajectory
    frames, step, count = get_pdb_frames(energies_structure_file.path, trajectory_file.path, snapshots, frames_limit)
    non_exceeding_interactions = [interaction for interaction in interactions if not interaction.get('exceeds', False)]

    # Load backup data in case there is a backup file
    if energies_backup.exists:
        print(' Recovering energies backup')
        interactions_data = load_json(energies_backup.path)
    else:
        interactions_data = [[] for interaction in non_exceeding_interactions]
    for frame_number, current_frame_pdb in enumerate(frames):
        # If we already have this frame in the backup then skip it
        if frame_number < len(interactions_data[0]):
            continue
        # Run the main analysis over the current frame
        # Append the result data for each interaction
        current_frame_structure = Structure.from_pdb_file(current_frame_pdb)
        frame_energies_data = get_frame_energy(current_frame_structure)
        for i, data in enumerate(frame_energies_data):
            interactions_data[i].append(data)
        # Save a backup just in case the process is interrupted further
        save_json(interactions_data, energies_backup.path)

    # Cleanup here some CMIP residual files since it is not to be run again
    # Remove the restart file since we do not use it and it may be heavy sometimes
    if restart_file.exists:
        restart_file.remove()
    # Remove fortran unit files generated when running CMIP
    # Note that we can not define where these files are written but they appear where CMIP is run
    fortran_unit_files = glob('fort.*')
    for filepath in fortran_unit_files:
        remove(filepath)

    # Now calculated atom average values through all frames for each pair of interaction agents
    output_summary = []
    for i, interaction in enumerate(non_exceeding_interactions):
        # Check if the interaction as been marked as 'exceeds', in which case we skip it
        if interaction.get('exceeds', False): continue
        # Get the numerated output filepath for this specific interaction
        numbered_output_analysis_filepath = numerate_filename(output_analysis_filepath, i)
        # Add the root of the output analysis filename to the run data
        analysis_name = get_analysis_name(numbered_output_analysis_filepath)
        # Get the interaction name
        name = interaction['name']
        # Add this interaction to the final summary
        output_summary.append({
            'name': name,
            'analysis': analysis_name
        })
        # If the output file already exists then skip this iteration
        if exists(numbered_output_analysis_filepath): continue
        # Get the main data
        data = interactions_data[i]
        # Format data
        agent1_output = format_data([ frame['agent1'] for frame in data ])
        agent2_output = format_data([ frame['agent2'] for frame in data ])
        # Format the results data and append it to the output data
        output = {
            'name': name,
            'agent1': agent1_output,
            'agent2': agent2_output,
            'version': '1.1.0'
        }
        # Export the current interaction analysis in json format
        save_json(output, numbered_output_analysis_filepath)

    # Finally, export the summary in json format
    save_json(output_summary, output_analysis_filepath)

    # Remove the backup to avoid accidentally reusing it when the output file is deleted
    energies_backup.remove()

    # Finally remove the reduced topology
    energies_structure_file.remove()

# Given a topology (e.g. pdb, prmtop), extract the atom elements in a CMIP friendly format
# Hydrogens bonded to carbons remain as 'H'
# Hydrogens bonded to oxygen are renamed as 'HO'
# Hydrogens bonded to nitrogen or sulfur are renamed as 'HN'
# Some heavy atom elements may be also modified (e.g. 'CL' -> 'Cl')
def set_cmip_elements (structure : 'Structure'):
    # Iterate over each atom to fix their element according to CMIP standards
    for a, atom in enumerate(structure.atoms):
        element = atom.element
        # Adapt hydrogens element to CMIP requirements
        if element == 'H':
            # We must find the element of the heavy atom this hydrogen is bonded to
            atom_bonds = atom.get_bonds()
            # There should be always only 1 bond
            if len(atom_bonds) != 1:
                print(f'Atom {atom.name} ({atom.index}) has {len(atom_bonds)} bonds')
                raise ValueError('An hydrogen should always have one and only one bond')
            bonded_atom_index = atom_bonds[0]
            bonded_atom_element = structure.atoms[bonded_atom_index].element
            # Hydrogens bonded to carbons remain as 'H'
            if bonded_atom_element == 'C':
                pass
            # Hydrogens bonded to oxygen are renamed as 'HO'
            elif bonded_atom_element == 'O':
                element = 'HO'
            # Hydrogens bonded to nitrogen or sulfur are renamed as 'HN'
            elif bonded_atom_element == 'N' or bonded_atom_element == 'S':
                element = 'HN'
            else:
                raise SystemExit(
                    'ERROR: Hydrogen bonded to not supported heavy atom: ' + bonded_atom_element)
        atom.element = element

# Set residue names with no endings
protein_mid_residue_names = { name for name in PROTEIN_RESIDUE_NAME_LETTERS if name[-1] not in {'N','C'} }
nucleic_mid_residue_names = { name for name in NUCLEIC_RESIDUE_NAME_LETTERS if name[-1] not in {'5','3'} }

# Change residue names in a structure to meet the CMIP requirements
# Change terminal residue names by adding an 'N' or 'C'
def name_terminal_residues (structure : 'Structure'):
    # Iterate chains
    for chain in structure.chains:
        # Check if the first residue is tagged as a terminal residue
        # If not, rename it
        first_residue = chain.residues[0]
        # In case it is a protein
        if first_residue.name in protein_mid_residue_names:
            first_residue.name += 'N'
        # In case it is RNA
        elif first_residue.name in nucleic_mid_residue_names:
            first_residue.name += '5'
        # Check if the last residue is tagged as 'C' terminal
        # If not, rename it
        last_residue = chain.residues[-1]
        # In case it is a protein
        if last_residue.name in protein_mid_residue_names:
            last_residue.name += 'C'
        # In case it is RNA
        elif last_residue.name in nucleic_mid_residue_names:
            last_residue.name += '3'

def mine_cmip_output (logs):
    center, density, units = (), (), ()
    grid_density_exp = r"^\s*Grid density:\s+(\d+)\s+(\d+)\s+(\d+)"
    grid_center_exp = r"^\s*Grid center:([- ]+\d+.\d+)([- ]+\d+.\d+)([- ]+\d+.\d+)"
    grid_units_exp = r"^\s*Grid units:\s+(\d+.\d+)\s+(\d+.\d+)\s+(\d+.\d+)"
    for line in logs:
        grid_center_groups = re.match(grid_center_exp, line)
        grid_density_groups = re.match(grid_density_exp, line)
        grid_units_groups = re.match(grid_units_exp, line)
        if grid_density_groups:
            density = tuple(float(grid_density_groups.group(i))
                            for i in (1, 2, 3))
        if grid_center_groups:
            center = tuple(float(grid_center_groups.group(i))
                           for i in (1, 2, 3))
        if grid_units_groups:
            units = tuple(float(grid_units_groups.group(i))
                          for i in (1, 2, 3))
    # If data mining fails there must be something wrong with the CMIP output
    if center == () or density == () or units == ():
        for line in logs:
            print(line)
        print('WARNING: CMIP output mining failed')
        raise SystemExit('ERROR: Something was wrong with CMIP')
    return center, density, units

# This function is used to create new grid parameters
# The new grid is expected to cover both input grids: agent 1 grid and agent 2 grid
def compute_new_grid (
        agent1_center,
        agent1_density,
        agent1_units,
        agent2_center,
        agent2_density,
        agent2_units,
        extra_density=1):
    new_center = []  # [(i + j) / 2 for i, j in zip(agent1_center, agent2_center)]
    new_density = []

    for k in range(3):
        min_prot = agent1_center[k] - agent1_density[k] * agent1_units[k]
        min_lig = agent2_center[k] - agent2_density[k] * agent2_units[k]
        min_new = min(min_prot, min_lig)
        max_prot = agent1_center[k] + agent1_density[k] * agent1_units[k]
        max_lig = agent2_center[k] + agent2_density[k] * agent2_units[k]
        max_new = max(max_prot, max_lig)

        dnew = int(abs(max_new - min_new) + extra_density)
        cnew = min_new + (dnew / 2)
        new_density.append(dnew)
        new_center.append(cnew)
    return new_center, new_density    

# Format data grouping atom energies by average ES/VDW
# Calculate values for the whole set of frames analyzed
# The canclulate it also for the 20% first frames and the 20% last frames separatedly
def format_data (data : list) -> dict:

    # First, reorder data by atoms and energies
    atom_count = len(data[0])

    atom_vdw_values = [[] for n in range(atom_count)]
    atom_es_values = [[] for n in range(atom_count)]
    atom_both_values = [[] for n in range(atom_count)]
    for frame in data:
        for a, values in enumerate(frame):
            if values == None: continue
            atom_vdw_values[a].append(values[0])
            atom_es_values[a].append(values[1])
            atom_both_values[a].append(values[2])

    # Calculate the atom averages from each energy
    atom_vdw_avg = [sum(v) / len(v) if len(v) > 0 else None for v in atom_vdw_values ]
    atom_es_avg = [sum(v) / len(v) if len(v) > 0 else None for v in atom_es_values]
    atom_both_avg = [sum(v) / len(v) if len(v) > 0 else None for v in atom_both_values]

    # Calculate the atom averages from each energy at the beginig and end of the trajectory
    # We take the initial 20% and the final 20% of frames to calculate each respectively
    p20_frames = len(data)
    p20 = round(p20_frames*0.2)
    if p20 == 0: p20 = 1

    # Initials
    atom_vdw_values_initial = [[] for n in range(atom_count)]
    atom_es_values_initial = [[] for n in range(atom_count)]
    atom_both_values_initial = [[] for n in range(atom_count)]
    for frame in data[:p20]:
        for a, values in enumerate(frame):
            if values == None: continue
            atom_vdw_values_initial[a].append(values[0])
            atom_es_values_initial[a].append(values[1])
            atom_both_values_initial[a].append(values[2])

    atom_vdw_avg_initial = [sum(v) / len(v) if len(v) > 0 else None for v in atom_vdw_values_initial]
    atom_es_avg_initial = [sum(v) / len(v) if len(v) > 0 else None for v in atom_es_values_initial]
    atom_both_avg_initial = [sum(v) / len(v) if len(v) > 0 else None for v in atom_both_values_initial]

    # Finals
    atom_vdw_values_final = [[] for n in range(atom_count)]
    atom_es_values_final = [[] for n in range(atom_count)]
    atom_both_values_final = [[] for n in range(atom_count)]
    for frame in data[-p20:]:
        for a, values in enumerate(frame):
            if values == None: continue
            atom_vdw_values_final[a].append(values[0])
            atom_es_values_final[a].append(values[1])
            atom_both_values_final[a].append(values[2])

    atom_vdw_avg_final = [sum(v) / len(v) if len(v) > 0 else None for v in atom_vdw_values_final]
    atom_es_avg_final = [sum(v) / len(v) if len(v) > 0 else None for v in atom_es_values_final]
    atom_both_avg_final = [sum(v) / len(v) if len(v) > 0 else None for v in atom_both_values_final]

    # Format the results data and append it to the output data
    output = {
        'vdw': atom_vdw_avg,
        'es': atom_es_avg,
        'both': atom_both_avg,
        'ivdw': atom_vdw_avg_initial,
        'ies': atom_es_avg_initial,
        'iboth': atom_both_avg_initial,
        'fvdw': atom_vdw_avg_final,
        'fes': atom_es_avg_final,
        'fboth': atom_both_avg_final,
    }

    return output