from os import remove, rename
from os.path import exists, getmtime
from shutil import copyfile
from subprocess import run, PIPE, Popen
from re import search
from time import time

from mddb_workflow.utils.auxiliar import load_json
from mddb_workflow.utils.constants import GROMACS_EXECUTABLE, GREY_HEADER, COLOR_END
from mddb_workflow.utils.file import File
from mddb_workflow.utils.type_hints import *
from mddb_workflow.tools.fix_gromacs_masses import fix_gromacs_masses


def run_gromacs(
    command : str, 
    user_input : Optional[str] = None,
    expected_output_filepath : Optional[str] = 'auto',
    show_output_logs : bool = False,
    show_error_logs : bool = False) -> tuple[str, str]:
    """ Set a function to call gromacs in a more confortable and standarized way:
    - Standard gromacs executable, which may be provided by the user
    - Gromacs mass fixes by using a custom atommass.dat file with extended atom names
    - Hidden unnecessary output logs and grey-colored necessary ones
    - Missing output checks
    Then return both output and error logs. """

    # Run a fix for gromacs if not done before
    # Note that this is run always at the moment the code is read, no matter the command or calling origin
    fix_gromacs_masses()

    # In case we have user input we must open a process to then pipe it in the gromacs process
    if user_input:
        # The -e option allows the interpretation of '\', which is critial for the make_ndx command
        # WARNING: Explicity split by whitespaces
        # WARNING: If not specified then breaklines are also removed, which is ciritcal for make_ndx
        user_input_process = Popen([ "echo", "-e", *user_input.split(' ') ], stdout=PIPE)

    # Get the time at the moment we start to run the command
    # WARNING: We must truncate this value, because the file mtime is truncated as well
    # Otherwise it may happen that gromacs runs in less than 1 seconds and the start time is higher
    start_time = time().__trunc__()

    # Set the gromacs process
    # Note that at this point the command is not yet run
    process = run([ GROMACS_EXECUTABLE, *command.split(), '-quiet' ],
        stdin = user_input_process.stdout if user_input else None,
        stdout = PIPE, stderr = PIPE if not show_error_logs else None)
    
    # If error is to be shown the color it in grey
    # This is usually used to see progress logs
    if show_error_logs: print(GREY_HEADER, end='\r')

    # Consume the gromacs process output thus running the command
    output_logs = process.stdout.decode()
    # Consume also error logs, but this will not run the command again
    error_logs = process.stderr.decode() if not show_error_logs else None

    # End the grey coloring
    if show_error_logs: print(COLOR_END, end='\r')

    # In case the expected output is set as 'auto' we must guess it from the command
    # Normally output comes after the '-o' option
    if expected_output_filepath == 'auto':
        command_splits = command.split()
        if '-o' not in command_splits: expected_output_filepath = None
        else:
            option_flag_index = command_splits.index('-o')
            expected_output_filepath = command_splits[option_flag_index + 1]

    # If an output file was expected then check it was created
    if expected_output_filepath:
        # Make sure output exists
        output_exists = exists(expected_output_filepath)
        # Make sure output have been generated by the gromacs command and it is not an old output
        output_is_old = False
        if output_exists:
            output_time = getmtime(expected_output_filepath)
            output_is_old = output_time < start_time
        # If output was not generated then we report the problem
        if not output_exists or output_is_old:
            # If we are missing the expetced output then report it
            print(output_logs)
            print(error_logs)
            # Recreate the exact command
            final_command = f'{GROMACS_EXECUTABLE} {command}'
            if user_input: final_command += f' (with user input "{user_input}")'
            raise SystemExit(f'Something went wrong with Gromacs while running "{GROMACS_EXECUTABLE} {command}"')
    
    # If all was good then show final logs but only if it was requested
    if show_output_logs: print(output_logs)

    # Return outputs
    return output_logs, error_logs


def get_first_frame (input_structure_filename : str, input_trajectory_filename : str, output_frame_filename : str):
    """ Get the first frame from a trajectory. """
    # Run Gromacs
    run_gromacs(f'trjconv -s {input_structure_filename} -f {input_trajectory_filename} \
                -o {output_frame_filename} -dump 0', user_input = 'System')

# Set function supported formats
get_first_frame.format_sets = [
    {
        'inputs': {
            'input_structure_filename': {'tpr', 'pdb', 'gro'},
            'input_trajectory_filename': {'xtc', 'trr'}
        },
        'outputs': {
            'output_frame_filename': {'pdb', 'gro'}
        }
    },
    {
        'inputs': {
            'input_structure_filename': None,
            'input_trajectory_filename': {'xtc', 'trr'}
        },
        'outputs': {
            'output_frame_filename': {'xtc', 'trr'}
        }
    },
    {
        'inputs': {
            'input_structure_filename': None,
            'input_trajectory_filename': {'pdb'}
        },
        'outputs': {
            'output_frame_filename': {'pdb', 'xtc', 'trr'}
        }
    },
    {
        'inputs': {
            'input_structure_filename': None,
            'input_trajectory_filename': {'gro'}
        },
        'outputs': {
            'output_frame_filename': {'gro', 'xtc', 'trr'}
        }
    }
]


def get_structure (input_structure_filename : str, input_trajectory_filename : str, output_structure_filename : str):
    """ Get the structure using the first frame getter function. """
    get_first_frame(input_structure_filename, input_trajectory_filename, output_structure_filename)
get_structure.format_sets = [
    {
        'inputs': {
            'input_structure_filename': {'tpr', 'pdb', 'gro'},
            'input_trajectory_filename': {'xtc', 'trr'}
        },
        'outputs': {
            'output_structure_filename': {'pdb', 'gro'}
        }
    }
]


def get_structure_alone (input_structure_filename : str, output_structure_filename : str):
    """ Convert the structure using the first frame getter function (no trajectory is required). """
    get_first_frame(input_structure_filename, input_structure_filename, output_structure_filename)
get_structure_alone.format_sets = [
    {
        'inputs': {
            'input_structure_filename': {'pdb', 'gro'},
        },
        'outputs': {
            'output_structure_filename': {'pdb', 'gro'}
        }
    }
]


def merge_and_convert_trajectories (input_trajectory_filenames : list[str], output_trajectory_filename : str):
    """ Get gromacs supported trajectories merged and converted to a different format. """
    # Get trajectory formats
    sample_trajectory = input_trajectory_filenames[0]
    sample_trajectory_file = File(sample_trajectory)
    input_trajectories_format = sample_trajectory_file.format
    output_trajectory_file = File(output_trajectory_filename)
    output_trajectory_format = output_trajectory_file.format
    auxiliar_single_trajectory_filename = '.single_trajectory.' + input_trajectories_format
    # If we have multiple trajectories then join them
    if len(input_trajectory_filenames) > 1:
        single_trajectory_filename = auxiliar_single_trajectory_filename
        run_gromacs(f'trjcat -f {" ".join(input_trajectory_filenames)} \
                    -o {single_trajectory_filename}')
    else:
        single_trajectory_filename = sample_trajectory
    # In case input and output formats are different we must convert the trajectory
    if input_trajectories_format != output_trajectory_format:
        run_gromacs(f'trjconv -f {single_trajectory_filename} \
                    -o {output_trajectory_filename}')
    else:
        copyfile(single_trajectory_filename, output_trajectory_filename)
    # Remove residual files
    if exists(auxiliar_single_trajectory_filename):
        remove(auxiliar_single_trajectory_filename)

merge_and_convert_trajectories.format_sets = [
    {
        'inputs': {
            'input_trajectory_filenames': {'xtc', 'trr'}
        },
        'outputs': {
            'output_trajectory_filename': {'xtc', 'trr'}
        }
    },
    {
        'inputs': {
            'input_trajectory_filenames': {'pdb'}
        },
        'outputs': {
            'output_trajectory_filename': {'pdb', 'xtc', 'trr'}
        }
    },
    {
        'inputs': {
            'input_trajectory_filenames': {'gro'}
        },
        'outputs': {
            'output_trajectory_filename': {'gro', 'xtc', 'trr'}
        }
    }
]


def get_trajectory_subset (
    input_trajectory_filename : str,
    output_trajectory_filename : str,
    start : int = 0,
    end : int = None,
    step : int = 1,
    frames : list[int] = [],
    skip : list[int] = []
):
    """ Get specific frames from a trajectory. """
    # Set a list with frame indices from
    output_frames = frames if frames and len(frames) > 0 else [ frame for frame in range(start, end, step) if frame not in skip ]

    # Generate the ndx file to target the desired frames
    auxiliar_ndx_filename = '.frames.ndx'
    generate_frames_ndx(output_frames, auxiliar_ndx_filename)

    # Now run gromacs trjconv command in order to extract the desired frames
    run_gromacs(f'trjconv -f {input_trajectory_filename} -o {output_trajectory_filename} \
                -fr {auxiliar_ndx_filename}', user_input = 'System')

    # Cleanup the auxiliar ndx file
    remove(auxiliar_ndx_filename)


get_trajectory_subset.format_sets = [
    {
        'inputs': {
            'input_trajectory_filename': {'xtc', 'trr'}
        },
        'outputs': {
            'output_trajectory_filename': {'xtc', 'trr'}
        }
    }
]


def filter_structure (
    input_structure_file : 'File',
    output_structure_file : 'File',
    input_selection : 'Selection'
):
    """ Filter trajectory atoms. """
    # Generate a ndx file with the desired selection
    filter_selection_name = 'filter'
    filter_index_content = input_selection.to_ndx(selection_name=filter_selection_name)
    filter_index_filename = '.filter.ndx'
    with open(filter_index_filename, 'w') as file:
        file.write(filter_index_content)

    # Filter the structure
    run_gromacs(f'editconf -f {input_structure_file.path} -o {output_structure_file.path} \
                -n {filter_index_filename}', user_input = filter_selection_name)

    # Cleanup the index file
    remove(filter_index_filename)

filter_structure.format_sets = [
    {
        'inputs': {
            'input_structure_file': {'pdb', 'gro'},
        },
        'outputs': {
            'output_structure_file': {'pdb', 'gro'}
        }
    }
]


def filter_trajectory (
    input_structure_file : 'File',
    input_trajectory_file : 'File',
    output_trajectory_file : 'File',
    input_selection : 'Selection'
):
    """ Filter trajectory atoms. """
    # Generate a ndx file with the desired selection
    filter_selection_name = 'filter'
    filter_index_content = input_selection.to_ndx(selection_name=filter_selection_name)
    filter_index_filename = '.filter.ndx'
    with open(filter_index_filename, 'w') as file:
        file.write(filter_index_content)

    # Filter the trajectory
    # Now run gromacs trjconv command in order to extract the desired frames
    run_gromacs(f'trjconv -s {input_structure_file.path} -f {input_trajectory_file.path} \
                -o {output_trajectory_file.path} -n {filter_index_filename}',
                user_input = filter_selection_name)

    # Cleanup the index file
    remove(filter_index_filename)

filter_trajectory.format_sets = [
    {
        'inputs': {
            'input_structure_file': {'tpr', 'pdb', 'gro'},
            'input_trajectory_file': {'xtc', 'trr'}
        },
        'outputs': {
            'output_trajectory_file': {'xtc', 'trr'}
        }
    }
]

# Set a regular expression to further mine data from gromacs logs
GROMACS_SYSTEM_ATOMS_REGEX = r'System\) has[ ]+([0-9]*) elements'


def mine_system_atoms_count (logs : str) -> int:
    """ Mine system atoms count from gromacs logs. """
    system_atoms_match = search(GROMACS_SYSTEM_ATOMS_REGEX, logs)
    if not system_atoms_match:
        print(logs)
        raise ValueError('Failed to mine Gromacs error logs')
    return int(system_atoms_match[1])


def get_tpr_atom_count (tpr_filepath : str) -> int:
    """ Count TPR atoms. """
    # Make sure the filepath is valid
    if not exists(tpr_filepath):
        raise ValueError('Trying to count atoms from a topology which does not exist')
    # Run Gromacs only to see the number of atoms in the TPR
    output_logs, error_logs = run_gromacs(f'convert-tpr -s {tpr_filepath}', user_input = "whatever")
    # Mine the number of atoms in the system from the logs
    atom_count = mine_system_atoms_count(error_logs)
    return atom_count


def read_and_parse_tpr (tpr_filepath : str) -> dict:
    """ Read and parse a tpr using the MDDB-specific tool from gromacs. """
    expected_output_filepath = 'siminfo.json'
    run_gromacs(f'dump -s {tpr_filepath} --json', expected_output_filepath = expected_output_filepath)
    parsed_tpr = load_json(expected_output_filepath)
    remove(expected_output_filepath)
    return parsed_tpr


def get_tpr_content (tpr_filepath : str) -> tuple[str, str]:
    """ Read a tpr file by converting it to ASCII. """
    # Read the tpr file making a 'dump'
    return run_gromacs(f'dump -s {tpr_filepath}')

# Regular expresion to mine atom charges
GROMACS_TPR_ATOM_CHARGES_REGEX = r"q=([0-9e+-. ]*),"


def get_tpr_charges (tpr_filepath : str) -> list[float]:
    """ Get tpr atom charges.
    This works for the new tpr format (tested in 122). """
    # Read the TPR
    tpr_content, tpr_error_logs = get_tpr_content(tpr_filepath)
    # Mine the atomic charges
    charges = []
    # Iterate tpr content lines
    for line in tpr_content.split('\n'):
        # Skip everything which is not atomic charges data
        if line[0:16] != '            atom': continue
        # Parse the line to get only charges
        match = search(GROMACS_TPR_ATOM_CHARGES_REGEX, line)
        if match: charges.append(float(match[1]))
    # If we successfully got atom charges then return them
    if len(charges) > 0: return charges
    # If there are no charges at the end then something went wrong
    print(tpr_error_logs)
    raise RuntimeError(f'Charges extraction from tpr file "{tpr_filepath}" has failed')

# Regular expresion to mine atom bonds
GROMACS_TPR_ATOM_BONDS_REGEX = r"^\s*([0-9]*) type=[0-9]* \((BONDS|CONSTR|CONNBONDS)\)\s*([0-9]*)\s*([0-9]*)$"
# Set a regular expression for SETTLE bonds, used for rigid waters
# ---- From the paper ------------------------------------------------------------------------------------
# The SETTLE can be applied to a four-point water model like TIP4P5 which has the fourth point with
# a certain charge and no mass if the force acting on the fourth point is distributed onto the other three
# points with masses in a reasonable manner.
# S. Miyamoto and P.A. Kollman, “SETTLE: An analytical version of the SHAKE and RATTLE algorithms for rigid
# water models,” J. Comp. Chem., 13 952–962 (1992)
# --------------------------------------------------------------------------------------------------------
# So it may happen that we encounter SETTLE with 4 atoms
# This is not yet supported, but at least we check if this is happening to raise an error when found
GROMACS_TPR_SETTLE_REGEX = r"^\s*([0-9]*) type=[0-9]* \(SETTLE\)\s*([0-9]*)\s*([0-9]*)\s*([0-9]*)\s*([0-9]*)$"


def get_tpr_bonds (tpr_filepath : str) -> list[ tuple[int, int] ]:
    """ Get tpr atom bonds. """
    # Read and parse the TPR
    parsed_tpr = read_and_parse_tpr(tpr_filepath)
    # Get the bonds only
    tpr_bonds = parsed_tpr['gromacs-topology']['bond']['value']
    return tpr_bonds


def filter_tpr (
    input_structure_file : 'File',
    output_structure_file : 'File',
    input_selection : 'Selection'
):
    """ Filter topology atoms.
    DANI: Note that a TPR file is not a structure but a topology
    DANI: However it is important that the argument is called 'structure' for the format finder"""
    # Generate a ndx file with the desired selection
    filter_selection_name = 'filter'
    filter_index_content = input_selection.to_ndx(selection_name=filter_selection_name)
    filter_index_filename = '.filter.ndx'
    with open(filter_index_filename, 'w') as file:
        file.write(filter_index_content)

    # Filter the tpr
    run_gromacs(f'convert-tpr -s {input_structure_file.path} -o {output_structure_file.path} \
                -n {filter_index_filename}', user_input = filter_selection_name)

    # Cleanup the index file
    remove(filter_index_filename)

filter_tpr.format_sets = [
    {
        'inputs': {
            'input_structure_file': {'tpr'},
        },
        'outputs': {
            'output_structure_file': {'tpr'}
        }
    }
]


def merge_xtc_files (current_file : str, new_file : str):
    """ Join xtc files.
    This is a minimal implementation of 'gmx trjcat' used in loops. """
    # If the current file does nt exist then set the new file as the current file
    if not exists(current_file):
        rename(new_file, current_file)
        return
    # Run trjcat
    run_gromacs(f'trjcat -f {new_file.path} {current_file} -o {current_file.path}')


def generate_frames_ndx (frames : list[int], filename : str):
    """ Generate a ndx file with a selection of frames. """
    # Add a header
    content = '[ frames ]\n'
    count = 0
    for frame in frames:
        # Add a breakline each 15 indices
        count += 1
        if count == 15:
            content += '\n'
            count = 0
        # Add a space between indices
        # Atom indices go from 0 to n-1
        # Add +1 to the index since gromacs counts from 1 to n
        content += str(frame + 1) + ' '
    content += '\n'
    # Write the file
    with open(filename, 'w') as file:
        file.write(content)

# DANI: No se usa, pero me costó un rato ponerla a punto así que la conservo
# Set a function to read and parse xpm files with a single matrix
# Inspired in https://gromacswrapper.readthedocs.io/en/latest/_modules/gromacs/fileformats/xpm.html#XPM
def parse_xpm (filename : str) -> list[ list[float] ]:
    with open(filename) as file:
        # First lines include metadata such as the title, description and legend
        # Read lines until we find the start of the array
        metadata = [file.readline()]
        while not metadata[-1].startswith("static char *gromacs_xpm[]"):
            metadata.append(file.readline())
        # The next line will contain the dimensions of the matrix
        # e.g. "7 7   14 1",
        dimensions = file.readline().replace('"','').replace(',','').split()
        x_dimension, y_dimension, entity_count, x_stride = [ int(i) for i in dimensions ]
        # Next lines contain every entity definition
        # Every entity has the following:
        # - A letter which is used to refer this entity later in the matrix
        # - A color in #XXXXXX format
        # - The actual value of the entity
        # e.g. "A  c #FFFFFF " /* "0" */,
        # e.g. "B  c #EBEBFF " /* "1" */,
        entities = {}
        for i in range(entity_count):
            line = file.readline()
            entity_id = line[1]
            entity_color = line[6:13]
            entity_value = line[18:].split('"')[1]
            entities[entity_id] = { 'value': entity_value, 'color': entity_color }
        # Next lines are the matrix axis values
        x_axis = []
        y_axis = []
        # Every line has a maximum of 80 labels
        x_lines = math.ceil(x_dimension / 80) # type: ignore
        for l in range(x_lines):
            line = file.readline()[12:-3].split()
            x_axis += [ int(v) for v in line ]
        y_lines = math.ceil(y_dimension / 80) # type: ignore
        for l in range(y_lines):
            line = file.readline()[12:-3].split()
            y_axis += [ int(v) for v in line ]
        # Next lines are the matrix rows
        matrix = []
        for l in range(y_dimension):
            line = file.readline()[1:1+x_dimension]
            row = [ letter for letter in line ]
            matrix.append(row)
        # Check the final matrix size is as expected
        if len(matrix) != y_dimension:
            raise ValueError('Different number of rows than expected')
        sample_row = matrix[-1]
        if len(sample_row) != x_dimension:
            raise ValueError('Different number of columns than expected')
        # Return the output
        return { 'entities': entities, 'x_axis': x_axis, 'y_axis': y_axis, 'matrix': matrix }


def pdb_filter (
    input_pdb_filepath : str,
    output_pdb_filepath : str,
    index_filepath : str,
    filter_group_name : str
):
    """ Filter atoms in a pdb file.
    This method conserves maximum resolution and chains. """
    # Filter the PDB
    run_gromacs(f'editconf -f {input_pdb_filepath} -o {output_pdb_filepath} \
                -n {index_filepath}', user_input = filter_group_name)


def xtc_filter(
    structure_filepath : str,
    input_trajectory_filepath : str,
    output_trajectory_filepath : str,
    index_filepath : str,
    filter_group_name : str
):
    """ Filter atoms in a xtc file.
    Note that here we do not hide the stderr.
    This is because it shows the progress.
    Instead we color the output grey. """
    # Filter the trajectory
    run_gromacs(f'trjconv -s {structure_filepath} -f {input_trajectory_filepath} \
        -o {output_trajectory_filepath} -n {index_filepath}', user_input = filter_group_name)


def tpr_filter(
    input_tpr_filepath : str,
    output_tpr_filepath : str,
    index_filepath : str,
    filter_group_name : str
):
    """ Filter atoms in both a pdb and a xtc file. """
    # Filter the topology
    run_gromacs(f'convert-tpr -s {input_tpr_filepath} -o {output_tpr_filepath} \
                -n {index_filepath}', user_input = filter_group_name)


def make_index (input_structure_file : 'File', output_index_file : 'File', mask : str) -> str:
    """ Create a .ndx file from a complex mask.
    e.g. no water and no ions -> !"Water"&!"Ion".
    This will return the group name to be further used. """
    # Make sure the
    #if output_index_file.exists: output_index_file.remove()
    # Run Gromacs
    run_gromacs(f'make_ndx -f {input_structure_file.path} -o {output_index_file.path}',
                user_input = f'{mask} \nq')
    # The group name is automatically assigned by gromacs
    # It equals the mask but removing any " symbols and with a few additional changes
    # WARNING: Not all mask symbols are supported here, beware of complex masks
    group_name = mask.replace('"','').replace('&','_&_').replace('|','_')
    # Check if the group was created
    content = read_ndx(output_index_file)
    created = group_name in content
    return group_name, created


def read_ndx (input_index_file : 'File') -> dict:
    """ Read a .ndx file """
    # Make sure the file exists
    if not input_index_file.exists:
        raise RuntimeError(f'Index file {input_index_file.path} does not exist')
    # Read the ndx file
    ndx_content = None
    with open(input_index_file.path, 'r') as file:
        ndx_content = file.readlines()
    # Parse its contents
    groups = {}
    current_group_name = None
    current_group_indices = None
    for line in ndx_content:
        # If it is the header of a group of indices
        if line[0] == '[':
            # Add current group to the final dict
            if current_group_name != None:
                groups[current_group_name] = current_group_indices
            # Set the name and the list of indices for the next group
            current_group_name = line[2:-3]
            current_group_indices = []
            continue
        # If it is a line of indices then parse it to actual numbers
        # Substract 1 since gromacs indices are 1-based while we want them 0-based
        current_group_indices += [ int(index) - 1 for index in line.split() ]
    # Add last group to the final dict
    groups[current_group_name] = current_group_indices
    # Finally return the parsed content
    return groups


ATOMS_LINE = r'\n# Atoms\s*([0-9]*)\n'
def get_atom_count (mysterious_file : 'File') -> int:
    """ Count atoms in a gromacs supported file. """
    output_logs, error_logs =  run_gromacs(f'check -f {mysterious_file.path}')
    search_results = search(ATOMS_LINE, error_logs)
    if not search_results: raise ValueError('Failed to mine atoms')
    return int(search_results[1])
